#!/usr/bin/env python3
import argparse, os, sys, getpass, secrets, struct, pathlib
from typing import Tuple
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

MAGIC = b"AE256"          # file signature
VERSION = 1               # format version
SALT_LEN = 16
NONCE_LEN = 12
ITERATIONS = 200_000

def derive_key(password: bytes, salt: bytes) -> bytes:
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,                 # AES-256 key
        salt=salt,
        iterations=ITERATIONS,
    )
    return kdf.derive(password)

def write_atomic(out_path: pathlib.Path, data: bytes):
    tmp = out_path.with_suffix(out_path.suffix + ".part")
    with open(tmp, "wb") as f:
        f.write(data)
        f.flush(); os.fsync(f.fileno())
    tmp.replace(out_path)

def read_all(path: pathlib.Path) -> bytes:
    with open(path, "rb") as f:
        return f.read()

def encrypt_file(in_path: pathlib.Path, out_path: pathlib.Path, password: str):
    plaintext = read_all(in_path)
    salt = secrets.token_bytes(SALT_LEN)
    key = derive_key(password.encode("utf-8"), salt)
    nonce = secrets.token_bytes(NONCE_LEN)
    aesgcm = AESGCM(key)
    ct = aesgcm.encrypt(nonce, plaintext, None)  # returns ciphertext||tag
    header = MAGIC + struct.pack("!B", VERSION) + salt + nonce
    write_atomic(out_path, header + ct)

def parse_header(blob: bytes) -> Tuple[int, bytes, bytes, bytes]:
    if len(blob) < len(MAGIC) + 1 + SALT_LEN + NONCE_LEN:
        raise ValueError("File too short or corrupted.")
    off = 0
    if blob[:len(MAGIC)] != MAGIC:
        raise ValueError("Not an AE256 file.")
    off += len(MAGIC)
    version = blob[off]; off += 1
    if version != VERSION:
        raise ValueError(f"Unsupported version: {version}")
    salt = blob[off:off+SALT_LEN]; off += SALT_LEN
    nonce = blob[off:off+NONCE_LEN]; off += NONCE_LEN
    ct = blob[off:]
    return version, salt, nonce, ct

def decrypt_file(in_path: pathlib.Path, out_path: pathlib.Path, password: str):
    blob = read_all(in_path)
    _, salt, nonce, ct = parse_header(blob)
    key = derive_key(password.encode("utf-8"), salt)
    aesgcm = AESGCM(key)
    try:
        pt = aesgcm.decrypt(nonce, ct, None)
    except Exception as e:
        raise ValueError("Decryption failed (wrong password or corrupted file).") from e
    write_atomic(out_path, pt)

def main():
    p = argparse.ArgumentParser(
        prog="aetool",
        description="AES-256-GCM file encryptor/decryptor (authenticated encryption).",
    )
    sub = p.add_subparsers(dest="cmd", required=True)

    enc = sub.add_parser("encrypt", help="Encrypt a file")
    enc.add_argument("input", type=pathlib.Path)
    enc.add_argument("-o", "--output", type=pathlib.Path, help="Output file (default: add .ae256)")

    dec = sub.add_parser("decrypt", help="Decrypt an .ae256 file")
    dec.add_argument("input", type=pathlib.Path)
    dec.add_argument("-o", "--output", type=pathlib.Path, help="Output file (default: strip .ae256)")

    args = p.parse_args()

    if args.cmd == "encrypt":
        inp = args.input
        if not inp.exists():
            p.error(f"Input file not found: {inp}")
        out = args.output or inp.with_suffix(inp.suffix + ".ae256")
        pwd1 = getpass.getpass("New password: ")
        pwd2 = getpass.getpass("Confirm password: ")
        if pwd1 != pwd2:
            print("Passwords do not match.", file=sys.stderr); sys.exit(2)
        encrypt_file(inp, out, pwd1)
        print(f"Encrypted -> {out}")

    elif args.cmd == "decrypt":
        inp = args.input
        if not inp.exists():
            p.error(f"Input file not found: {inp}")
        if args.output:
            out = args.output
        else:
            out = inp.with_suffix(inp.suffix.replace(".ae256", "")) if inp.suffix.endswith("ae256") else inp.with_suffix(".dec")
        pwd = getpass.getpass("Password: ")
        try:
            decrypt_file(inp, out, pwd)
        except Exception as e:
            print(str(e), file=sys.stderr); sys.exit(3)
        print(f"Decrypted -> {out}")

if __name__ == "__main__":
    main()
